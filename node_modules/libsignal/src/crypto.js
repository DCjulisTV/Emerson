// vim: ts=4:sw=4

'use strict';

const nodeCrypto = require('crypto');
const assert = require('assert');

/**
 * Asserts that the given value is an instance of Buffer.
 * @param {*} value The value to check.
 * @returns {Buffer} The value if it's a Buffer.
 * @throws {TypeError} If the value is not a Buffer.
 */
function assertBuffer(value) {
    if (!(value instanceof Buffer)) {
        throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);
    }
    return value;
}

/**
 * Encrypts data using AES-256-CBC.
 * @param {Buffer} key The encryption key (32 bytes for AES-256).
 * @param {Buffer} data The data to encrypt.
 * @param {Buffer} iv The initialization vector (16 bytes).
 * @returns {Buffer} The encrypted data.
 */
function encrypt(key, data, iv) {
    assertBuffer(key);
    assertBuffer(data);
    assertBuffer(iv);

    const cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);
    return Buffer.concat([cipher.update(data), cipher.final()]);
}

/**
 * Decrypts data using AES-256-CBC.
 * @param {Buffer} key The decryption key (32 bytes for AES-256).
 * @param {Buffer} data The data to decrypt.
 * @param {Buffer} iv The initialization vector (16 bytes).
 * @returns {Buffer} The decrypted data.
 */
function decrypt(key, data, iv) {
    assertBuffer(key);
    assertBuffer(data);
    assertBuffer(iv);

    const decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);
    return Buffer.concat([decipher.update(data), decipher.final()]);
}

/**
 * Calculates a SHA256 HMAC (Message Authentication Code).
 * @param {Buffer} key The HMAC key.
 * @param {Buffer} data The data to sign.
 * @returns {Buffer} The calculated HMAC.
 */
function calculateMAC(key, data) {
    assertBuffer(key);
    assertBuffer(data);

    const hmac = nodeCrypto.createHmac('sha256', key);
    hmac.update(data);
    return Buffer.from(hmac.digest());
}

/**
 * Calculates a SHA512 hash of the given data.
 * @param {Buffer} data The data to hash.
 * @returns {Buffer} The SHA512 hash.
 */
function hash(data) {
    assertBuffer(data);

    const sha512 = nodeCrypto.createHash('sha512');
    sha512.update(data);
    return sha512.digest();
}

/**
 * Derives secrets using HKDF (HMAC-based Key Derivation Function) as specified in RFC 5869.
 * This specific implementation returns up to three 32-byte chunks.
 * @param {Buffer} input The input keying material (IKM).
 * @param {Buffer} salt The salt (must be 32 bytes).
 * @param {Buffer} info The optional context and application specific information (info).
 * @param {number} [chunks=3] The number of 32-byte chunks to derive (1, 2, or 3).
 * @returns {Buffer[]} An array of derived secret buffers.
 * @throws {Error} If the salt length is incorrect or if `chunks` is out of range.
 */
function deriveSecrets(input, salt, info, chunks = 3) {
    assertBuffer(input);
    assertBuffer(salt);
    assertBuffer(info);

    if (salt.byteLength !== 32) {
        throw new Error("Got salt of incorrect length. Salt must be 32 bytes.");
    }
    assert(chunks >= 1 && chunks <= 3, "Chunks must be between 1 and 3 (inclusive).");

    // HKDF-Extract: PRK = HMAC-Sha256(salt, IKM)
    const PRK = calculateMAC(salt, input);

    // HKDF-Expand
    const signed = [];
    let T = Buffer.alloc(0); // T(0) is an empty string

    for (let i = 1; i <= chunks; i++) {
        // T(i) = HMAC-Sha256(PRK, T(i-1) || info || L)
        // L is a single octet representing the counter i
        const inputForHmac = Buffer.concat([T, info, Buffer.from([i])]);
        T = calculateMAC(PRK, inputForHmac);
        signed.push(T);
    }

    return signed;
}

/**
 * Verifies a MAC against calculated data.
 * @param {Buffer} data The data for which the MAC was calculated.
 * @param {Buffer} key The key used for MAC calculation.
 * @param {Buffer} mac The MAC to verify.
 * @param {number} length The expected length of the MAC.
 * @throws {Error} If the MAC length is incorrect or if the MAC does not match.
 */
function verifyMAC(data, key, mac, length) {
    const calculatedMac = calculateMAC(key, data).slice(0, length);

    if (mac.length !== length || calculatedMac.length !== length) {
        throw new Error("Bad MAC length: provided MAC or calculated MAC does not match expected length.");
    }

    // Use a timing-safe comparison to prevent timing attacks
    if (!nodeCrypto.timingSafeEqual(mac, calculatedMac)) {
        throw new Error("Bad MAC: Message authentication code does not match.");
    }
}

module.exports = {
    deriveSecrets,
    decrypt,
    encrypt,
    hash,
    calculateMAC,
    verifyMAC
};
